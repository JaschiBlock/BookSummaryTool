<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Zeichenzähler (ohne Enter) mit linearem Kapitelziel</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    :root {
      --ok: #0a7d2e;
      --warn: #c77700;
      --bad: #b00020;
      --fg: #111;
      --muted: #666;
      --border: #ddd;
      --bg: #fff;
      --accent: #0a84ff;
      --tooltip-bg: #222;
      --shadow: 0 6px 24px rgba(0,0,0,.12);
      --gap: 16px;
      --hud-pad: 12px;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; line-height: 1.45; color: var(--fg); background: var(--bg); }
    h1 { font-size: 1.3rem; margin: 0 0 16px; }
    label { font-weight: 600; display: block; margin: 10px 0 6px; }
    input[type="number"], input[type="text"], textarea, select {
      width: 100%; box-sizing: border-box; font: inherit; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg);
    }
    textarea { min-height: 60vh; resize: vertical; }
    .grid { display: grid; gap: 14px; grid-template-columns: 1fr; margin-bottom: 10px; }
    .card { border: 1px solid var(--border); border-radius: 10px; padding: 12px; background: var(--bg); }
    .flex { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row { display: grid; gap: 10px; }
    .btn { padding: 10px 14px; cursor: pointer; border: 1px solid #333; border-radius: 8px; background: #111; color: #fff; }
    .btn.secondary { background: #fff; color: #111; border: 1px solid #999; }
    .btn.ghost { background: transparent; color: var(--muted); border: 1px dashed #bbb; }
    .meta { color: var(--muted); font-size: 0.95em; }

    /* Layout */
    .layout { display: grid; gap: 20px; }
    @media (min-width: 980px) {
      .layout { grid-template-columns: 1fr 2fr; align-items: start; }
    }

    /* Chapter arrows (main UI) */
    .chapter-ctrls { display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; }
    .chapter-ctrls .arrow { padding: 8px 10px; border-radius: 8px; border: 1px solid #999; background: #fff; color: #111; cursor: pointer; }
    .chapter-ctrls .arrow:disabled { opacity: .5; cursor: default; }
    .chapter-ctrls .inline-meta { color: var(--muted); font-size: .95em; white-space: nowrap; }

    /* HUD */
    .hud {
      position: fixed;
      right: 16px;
      z-index: 9999;
      background: var(--bg);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      min-width: 300px;
      max-width: 420px;
      padding: var(--hud-pad);
      max-height: 80vh;
      overflow-y: auto;
      transition: opacity .15s ease, transform .15s ease;
    }
    .hud .rows { display: grid; gap: 8px; }
    .hud .line { display: flex; justify-content: space-between; gap: 8px; font-size: .95em; }
    .hud .label { color: var(--muted); display: flex; align-items: center; gap: 6px; }
    .hud .val { font-weight: 700; }
    .hud .head { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 6px; }
    .hud .head .title { font-weight: 700; color: var(--muted); font-size: .9em; }
    .hud .head .tools { display: flex; gap: 6px; }
    .hud .mini-btn { padding: 6px 8px; font-size: .85em; border-radius: 6px; border: 1px solid #bbb; background: #fff; color: #333; cursor: pointer; }
    .hud .mini-btn.toggled { background: #111; color: #fff; border-color: #111; }

    .hud .mini {
      width: 100%; height: 8px; background: #eee; border: 1px solid #ddd;
      border-radius: 999px; overflow: hidden; position: relative;
    }
    .hud .mini .b { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), #66b6ff); transition: width .15s ease; }
    .hud .mini .b.over { background: linear-gradient(90deg, #ff6b6b, #ff3b30); }
    .hud .mini .band {
      position: absolute; top: -3px; height: 14px; border-radius: 3px; opacity: .25;
      background: linear-gradient(90deg, #00c853, #ffd600);
    }
    .hud .delta-ok { color: var(--ok); font-weight: 700; }
    .hud .delta-warn { color: var(--warn); font-weight: 700; }
    .hud .delta-bad { color: var(--bad); font-weight: 700; }

    .hud .chapline { align-items: center; }
    .hud .chapline .ctrl { display: inline-flex; align-items: center; gap: 6px; }
    .hud .chapline .ctrl .mini-btn:disabled { opacity: .5; cursor: default; }

    /* Tooltip */
    .tip {
      position: relative; display: inline-flex; align-items: center; justify-content: center;
      width: 16px; height: 16px; border-radius: 50%; font-size: 12px; line-height: 1;
      color: var(--accent); border: 1px solid var(--accent); cursor: help; user-select: none; z-index: 1; flex: 0 0 16px;
    }
    .tip::after {
      content: attr(data-tip);
      position: absolute; bottom: 130%; left: 50%; transform: translateX(-50%);
      background: var(--tooltip-bg); color: #fff; padding: 6px 8px; border-radius: 6px;
      white-space: nowrap; font-size: 0.85em; box-shadow: 0 6px 18px rgba(0,0,0,.2);
      opacity: 0; pointer-events: none; transition: opacity .12s ease;
    }
    .tip::before {
      content: ""; position: absolute; bottom: 118%; left: 50%; transform: translateX(-50%);
      border: 6px solid transparent; border-top-color: var(--tooltip-bg); opacity: 0; transition: opacity .12s ease;
    }
    .tip:hover::after, .tip:hover::before, .tip:focus-visible::after, .tip:focus-visible::before, .tip[aria-expanded="true"]::after, .tip[aria-expanded="true"]::before { opacity: 1; }

    /* HUD toggle button (always visible, both mobile & desktop) */
    #toggleHud {
      position: fixed;
      left: 12px;
      bottom: calc(12px + env(safe-area-inset-bottom, 0px));
      z-index: 99999;
      display: inline-block;
      opacity: .9;
    }

    /* HUD compact */
    .hud.compact { padding: 10px; min-width: 260px; }
    .hud.compact .chapline,
    .hud.compact .line.soll { display: none; }
    .hud.compact .head .title { display: none; }

    /* LocalStorage warning note */
    .warn-note {
      background: #fff8e1; border: 1px solid #ffe082; color: #5d4037; padding: 8px 10px; border-radius: 8px; font-size: .92em;
    }

    /* Mobile tweaks */
    @media (max-width: 680px) {
      .hud {
        right: 12px;
        min-width: 85vw;
        max-width: 92vw;
        font-size: 0.92rem;
        padding: 10px;
        max-height: 60vh;
      }
    }

    /* Guided Tour */
    .tour { position: fixed; inset: 0; z-index: 100000; display: none; }
    .tour.active { display: block; }
    .tour .spot {
      position: absolute; border: 2px solid var(--accent); border-radius: 10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.6); transition: all .15s ease;
      pointer-events: none;
    }
    .tour .box {
      position: absolute; max-width: min(90vw, 420px);
      background: #111; color: #fff; border-radius: 10px; padding: 12px; box-shadow: var(--shadow);
      transition: top .15s ease, left .15s ease, transform .15s ease;
    }
    .tour .box p { margin: 0 0 10px; }
    .tour .actions { display: flex; gap: 8px; justify-content: flex-end; }
    .tour .small { font-size: .9em; opacity: .8; }
  </style>
</head>
<body>
  <h1>Zeichenzähler (ohne Enter) mit linearem Kapitelziel</h1>

  <div class="layout">
    <!-- Linke Spalte: Einstellungen -->
    <div class="left">
      <div class="grid">
        <div class="card">
          <div class="row">
            <label for="chapters">Kapitelanzahl (N)</label>
            <input id="chapters" type="number" min="1" step="1" value="30" />

            <label for="currentChapter">Aktuelles Kapitel (k)</label>
            <div id="chapterControls" class="chapter-ctrls">
              <button id="prevChapter" class="arrow" title="Kapitel zurück">←</button>
              <input id="currentChapter" type="number" min="1" step="1" value="1" style="max-width:100px" />
              <button id="nextChapter" class="arrow" title="Kapitel vor">→</button>
              <span class="inline-meta">/ <span id="chaptersTotalDisplay">30</span></span>
            </div>

            <label for="minTotal">Gesamt-Minimum Zeichen (ohne Enter, gesamtes Buch)</label>
            <input id="minTotal" type="number" min="0" step="1" value="1100" />

            <label for="maxTotal">Gesamt-Maximum Zeichen (ohne Enter, gesamtes Buch)</label>
            <input id="maxTotal" type="number" min="0" step="1" value="1500" />

            <div class="meta">
              Linear: Bis Kapitel k sind k/N des Gesamt-Min/Max erlaubt.
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <label for="autosaveToggle">Autosave</label>
            <div class="flex">
              <select id="autosaveToggle">
                <option value="on" selected>Ein</option>
                <option value="off">Aus</option>
              </select>
              <label for="interval" style="margin:0 0 0 8px">Intervall (Sek.)</label>
              <input id="interval" type="number" min="2" step="1" value="5" style="max-width:120px" />
            </div>
            <div class="flex" style="margin-top:8px">
              <button id="save" class="btn">Jetzt speichern</button>
              <button id="export" class="btn secondary">Export .txt</button>
              <input id="importFile" type="file" accept=".txt,.md,.rtf,.csv,.json" style="display:none" />
              <button id="importBtn" class="btn secondary">Import .txt/.md</button>
              <button id="clear" class="btn secondary">Alles löschen</button>
            </div>

            <!-- LocalStorage sichern/laden -->
            <div class="flex" style="margin-top:8px">
              <button id="lsExport" class="btn secondary">LocalStorage sichern</button>
              <button id="lsImportBtn" class="btn secondary">LocalStorage laden</button>
              <input id="lsImportFile" type="file" accept="application/json" style="display:none" />
            </div>
            <div class="warn-note">
              ⚠ Achtung: Der Stand liegt nur lokal im Browser. Er kann verloren gehen, wenn du im privaten/Inkognito-Modus arbeitest, Browserdaten (Cache/Verlauf) löschst, den Browser/PC zurücksetzt, Speicherbereinigungen greifen oder du ohne Export den Browser/ das Gerät wechselst.
            </div>

            <div id="saveInfo" class="meta"></div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="flex">
              <button id="toggleCompact" class="btn ghost">Kompaktmodus</button>
              <button id="startTour" class="btn ghost">Geführte Tour starten</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Rechte Spalte: Editor -->
    <div class="right">
      <label for="text">Buch-Text</label>
      <textarea id="text" placeholder="Füge hier deinen Text ein oder schreibe direkt los..."></textarea>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" class="hud" aria-live="polite">
    <div class="head">
      <div class="title">HUD</div>
      <div class="tools">
        <button id="hudCompactBtn" class="mini-btn" title="Kompaktmodus umschalten">Kompakt</button>
        <button id="hudHideBtn" class="mini-btn" title="HUD ein-/ausblenden">Hide</button>
        <button id="hudHelpBtn" class="mini-btn" title="Geführte Tour">?</button>
      </div>
    </div>
    <div class="rows" id="hudContent"></div>
  </div>

  <!-- HUD Toggle (always available) -->
  <button id="toggleHud" class="btn secondary" aria-controls="hud" aria-expanded="true">HUD ausblenden</button>

  <!-- Guided Tour -->
  <div id="tour" class="tour" aria-live="polite" aria-modal="true">
    <div id="tourSpot" class="spot"></div>
    <div id="tourBox" class="box">
      <p id="tourText">Beschreibung</p>
      <div class="actions">
        <button id="tourSkip" class="btn secondary" title="Tour beenden">Beenden</button>
        <button id="tourPrev" class="btn secondary" title="Zurück">Zurück</button>
        <button id="tourNext" class="btn" title="Weiter">Weiter</button>
      </div>
      <div class="small" id="tourProgress" style="margin-top:6px"></div>
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const LS_KEY = "buchKapitelCounter_v6";
    const TOUR_FLAG = LS_KEY + "_tourDone";
    const DEFAULTS = { minTotal: 1100, maxTotal: 1500 };
    const el = id => document.getElementById(id);

    function countWithoutNewlines(str) { return (str || "").replace(/\r?\n/g, "").length; }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    function formatDT(d = new Date()) {
      return d.toLocaleString(undefined, {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      });
    }
    function rectsOverlap(a, b, pad = 0) {
      return !(a.right < b.left + pad || a.left > b.right - pad || a.bottom < b.top + pad || a.top > b.bottom - pad);
    }

    // ---------- Elements ----------
    const textEl = el("text");
    const chaptersEl = el("chapters");
    const currentEl = el("currentChapter");
    const prevChapterBtn = el("prevChapter");
    const nextChapterBtn = el("nextChapter");
    const chaptersTotalDisplay = el("chaptersTotalDisplay");
    const minTotalEl = el("minTotal");
    const maxTotalEl = el("maxTotal");

    const autosaveToggleEl = el("autosaveToggle");
    const intervalEl = el("interval");
    const saveInfoEl = el("saveInfo");
    const saveBtn = el("save");
    const exportBtn = el("export");
    const importBtn = el("importBtn");
    const importFileEl = el("importFile");
    const clearBtn = el("clear");

    const hudEl = el("hud");
    const hudContentEl = el("hudContent");
    const toggleHudBtn = el("toggleHud");
    const hudCompactBtn = el("hudCompactBtn");
    const hudHideBtn = el("hudHideBtn");
    const hudHelpBtn = el("hudHelpBtn");
    const toggleCompactBtn = el("toggleCompact");

    const lsExportBtn = el("lsExport");
    const lsImportBtn = el("lsImportBtn");
    const lsImportFile = el("lsImportFile");

    // Guided tour elements
    const tourEl = el("tour");
    const tourSpot = el("tourSpot");
    const tourBox = el("tourBox");
    const tourText = el("tourText");
    const tourPrev = el("tourPrev");
    const tourNext = el("tourNext");
    const tourSkip = el("tourSkip");
    const tourProgress = el("tourProgress");

    // ---------- State ----------
    const state = {
      minTotal: DEFAULTS.minTotal,
      maxTotal: DEFAULTS.maxTotal,
      lastSavedTs: null,
      hudVisible: true,
      compact: false
    };
    let autosaveTimer = null;

    // ---------- Logic ----------
    function getEffectiveTotals() {
      const effMin = Math.min(state.minTotal, state.maxTotal);
      const effMax = Math.max(state.minTotal, state.maxTotal);
      return { effMin, effMax };
    }

    function renderHUDContent() {
      const chapters = clamp(parseInt(chaptersEl.value || "1", 10), 1, 1e6);
      const current = clamp(parseInt(currentEl.value || "1", 10), 1, chapters);
      const text = textEl.value || "";
      const count = countWithoutNewlines(text);
      const { effMin, effMax } = getEffectiveTotals();

      const minAllowed = Math.floor((current / chapters) * effMin);
      const maxAllowed = Math.floor((current / chapters) * effMax);

      let deltaTxt = "";
      let deltaClass = "delta-ok";
      if (count > maxAllowed) { const over = count - maxAllowed; deltaTxt = `Über Maximum: +${over.toLocaleString("de-DE")} Zeichen`; deltaClass = "delta-bad"; }
      else if (count < minAllowed) { const need = minAllowed - count; deltaTxt = `Unter Minimum: noch ${need.toLocaleString("de-DE")} Zeichen bis Minimum`; deltaClass = "delta-warn"; }
      else { const remain = maxAllowed - count; deltaTxt = `Verbleibend bis Maximum: ${remain.toLocaleString("de-DE")} Zeichen`; deltaClass = "delta-ok"; }

      const pctNow = maxAllowed > 0 ? Math.min(count / maxAllowed, 1) * 100 : 0;
      const bandStartPct = maxAllowed > 0 ? Math.max(0, Math.min(100, (minAllowed / maxAllowed) * 100)) : 0;
      const bandWidthPct = maxAllowed > 0 ? Math.max(0, 100 - bandStartPct) : 0;

      const tipCount = "Leerzeichen & Tabulatoren zählen. Enter/Zeilenumbrüche zählen nicht.";
      const tipSollKap = `Linear: Bis Kapitel sind k/N vom Gesamtsoll erlaubt.`;
      const tipMini = "Balken = Fortschritt gegen Soll-Max. Grün-Gelb-Band = 'OK'-Bereich ab Soll-Min.";

      if (state.compact) {
        hudContentEl.innerHTML = `
          <div class="line">
            <span class="label">Ist <span class="tip" tabindex="0" role="button" aria-expanded="false" data-tip="${tipCount}">i</span></span>
            <span class="val">${count.toLocaleString("de-DE")}</span>
          </div>
          <div class="mini" title="${tipMini}">
            <div class="band" style="left:${bandStartPct}%; width:${bandWidthPct}%"></div>
            <div class="b ${count > maxAllowed ? "over" : ""}" style="width:${pctNow}%"></div>
          </div>
          <div class="line">
            <span class="label">Delta</span>
            <span class="${deltaClass}">${deltaTxt}</span>
          </div>
        `;
      } else {
        hudContentEl.innerHTML = `
          <div class="line">
            <span class="label">Ist (ohne Enter) <span class="tip" tabindex="0" role="button" aria-expanded="false" data-tip="${tipCount}">i</span></span>
            <span class="val">${count.toLocaleString("de-DE")}</span>
          </div>

          <div class="line chapline">
            <span class="label">Kapitel</span>
            <span class="ctrl">
              <button id="hudPrev" class="mini-btn" title="Kapitel zurück">‹</button>
              <span class="val">${current} / ${chapters}</span>
              <button id="hudNext" class="mini-btn" title="Kapitel vor">›</button>
            </span>
          </div>

          <div class="line soll">
            <span class="label">Soll bis Kapitel <span class="tip" tabindex="0" role="button" aria-expanded="false" data-tip="${tipSollKap}">i</span></span>
            <span class="val">${minAllowed.toLocaleString("de-DE")} – ${maxAllowed.toLocaleString("de-DE")}</span>
          </div>

          <div class="mini" title="${tipMini}">
            <div class="band" style="left:${bandStartPct}%; width:${bandWidthPct}%"></div>
            <div class="b ${count > maxAllowed ? "over" : ""}" style="width:${pctNow}%"></div>
          </div>

          <div class="line">
            <span class="label">Delta</span>
            <span class="${deltaClass}">${deltaTxt}</span>
          </div>
        `;
      }

      // HUD arrow listeners
      const hudPrev = document.getElementById("hudPrev");
      const hudNext = document.getElementById("hudNext");
      if (hudPrev) hudPrev.addEventListener("click", () => { stepChapter(-1); });
      if (hudNext) hudNext.addEventListener("click", () => { stepChapter(+1); });

      // Tooltips click-to-toggle
      hudEl.querySelectorAll(".tip").forEach(t => {
        t.addEventListener("click", (e) => {
          e.stopPropagation();
          const expanded = t.getAttribute("aria-expanded") === "true";
          hudEl.querySelectorAll(".tip[aria-expanded='true']").forEach(o => o.setAttribute("aria-expanded","false"));
          t.setAttribute("aria-expanded", expanded ? "false" : "true");
        }, { once: true });
      });
    }

    function updateUI() {
      const chapters = clamp(parseInt(chaptersEl.value || "1", 10), 1, 1e6);
      chaptersEl.value = chapters;
      chaptersTotalDisplay.textContent = String(chapters);

      let current = parseInt(currentEl.value || "1", 10);
      current = clamp(current, 1, chapters);
      currentEl.value = current;

      // Arrow button enable/disable
      prevChapterBtn.disabled = current <= 1;
      nextChapterBtn.disabled = current >= chapters;

      renderHUDContent();
      autoPlaceHUD();
    }

    function saveNow(note = "") {
      const data = {
        text: textEl.value || "",
        chapters: parseInt(chaptersEl.value || "1", 10),
        current: parseInt(currentEl.value || "1", 10),
        minTotal: state.minTotal,
        maxTotal: state.maxTotal,
        autosave: autosaveToggleEl.value,
        intervalSec: Math.max(2, parseInt(intervalEl.value || "5", 10)),
        compact: !!state.compact,
        ts: Date.now()
      };
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(data));
        state.lastSavedTs = data.ts;
        saveInfoEl.textContent = `Gespeichert: ${formatDT(new Date(data.ts))}${note ? " • " + note : ""}`;
      } catch (e) {
        saveInfoEl.textContent = "Konnte nicht lokal speichern.";
      }
      updateUI();
    }

    function scheduleAutosave() {
      if (autosaveTimer) { clearInterval(autosaveTimer); autosaveTimer = null; }
      const enabled = autosaveToggleEl.value === "on";
      const sec = Math.max(2, parseInt(intervalEl.value || "5", 10));
      if (enabled) { autosaveTimer = setInterval(() => saveNow("Autosave"), sec * 1000); }
    }

    function loadFromStorage() {
      const raw = localStorage.getItem(LS_KEY);
      if (raw) {
        try {
          const d = JSON.parse(raw);
          if (Number.isFinite(d.chapters)) chaptersEl.value = d.chapters;
          if (Number.isFinite(d.current)) currentEl.value = d.current;
          if (Number.isFinite(d.minTotal)) { state.minTotal = Math.max(0, d.minTotal); minTotalEl.value = state.minTotal; }
          else { state.minTotal = DEFAULTS.minTotal; minTotalEl.value = DEFAULTS.minTotal; }
          if (Number.isFinite(d.maxTotal)) { state.maxTotal = Math.max(0, d.maxTotal); maxTotalEl.value = state.maxTotal; }
          else { state.maxTotal = DEFAULTS.maxTotal; maxTotalEl.value = DEFAULTS.maxTotal; }
          if (typeof d.text === "string") textEl.value = d.text;
          if (d.autosave === "on" || d.autosave === "off") autosaveToggleEl.value = d.autosave;
          if (Number.isFinite(d.intervalSec)) intervalEl.value = Math.max(2, d.intervalSec);
          if (typeof d.compact === "boolean") state.compact = d.compact;
          if (Number.isFinite(d.ts)) { state.lastSavedTs = d.ts; saveInfoEl.textContent = `Zuletzt gespeichert: ${formatDT(new Date(d.ts))}`; }
        } catch {
          state.minTotal = DEFAULTS.minTotal; minTotalEl.value = DEFAULTS.minTotal;
          state.maxTotal = DEFAULTS.maxTotal; maxTotalEl.value = DEFAULTS.maxTotal;
        }
      } else {
        state.minTotal = DEFAULTS.minTotal; minTotalEl.value = DEFAULTS.minTotal;
        state.maxTotal = DEFAULTS.maxTotal; maxTotalEl.value = DEFAULTS.maxTotal;
      }
      hudEl.classList.toggle("compact", state.compact);
      updateUI();
      scheduleAutosave();
    }

    function exportTxt() {
      const content = textEl.value || "";
      const count = countWithoutNewlines(content);
      const filename = `buch_${count}_zeichen_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.txt`;
      const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    function clearAll() {
      if (!confirm("Wirklich alles löschen? (Text & Einstellungen)")) return;
      textEl.value = "";
      chaptersEl.value = 30;
      currentEl.value = 1;
      state.minTotal = DEFAULTS.minTotal;
      state.maxTotal = DEFAULTS.maxTotal;
      minTotalEl.value = DEFAULTS.minTotal;
      maxTotalEl.value = DEFAULTS.maxTotal;
      autosaveToggleEl.value = "on";
      intervalEl.value = 5;
      state.lastSavedTs = null;
      state.compact = false;
      localStorage.removeItem(LS_KEY);
      saveInfoEl.textContent = "";
      hudEl.classList.remove("compact");
      updateUI();
      scheduleAutosave();
    }

    function stepChapter(delta) {
      const chapters = clamp(parseInt(chaptersEl.value || "1", 10), 1, 1e6);
      let current = clamp(parseInt(currentEl.value || "1", 10), 1, chapters);
      current = clamp(current + delta, 1, chapters);
      currentEl.value = current;
      updateUI(); saveNow();
    }

    // ---------- HUD auto-placement & keyboard ergonomics ----------
    function candidateRects(width, height) {
      const right = 16;
      const topMargin = 12 + (window.visualViewport?.offsetTop || 0);
      const bottomMargin = 16 + (window.visualViewport ? (window.innerHeight - (window.visualViewport.height + window.visualViewport.offsetTop)) : 0);
      const topRect = { left: window.innerWidth - right - width, top: topMargin, right: window.innerWidth - right, bottom: topMargin + height };
      const bottomRect = { left: window.innerWidth - right - width, top: window.innerHeight - bottomMargin - height, right: window.innerWidth - right, bottom: window.innerHeight - bottomMargin };
      return { topRect, bottomRect };
    }
    function autoPlaceHUD() {
      if (!state.hudVisible) return;
      const width = hudEl.offsetWidth;
      const height = hudEl.offsetHeight;
      const { topRect, bottomRect } = candidateRects(width, height);
      const taRect = textEl.getBoundingClientRect();
      const bottomOverlap = rectsOverlap(bottomRect, taRect, 8);
      const topOverlap = rectsOverlap(topRect, taRect, 8);
      if (bottomOverlap && !topOverlap) { hudEl.style.top = `${topRect.top}px`; hudEl.style.bottom = "auto"; }
      else { hudEl.style.bottom = `${window.innerHeight - bottomRect.bottom}px`; hudEl.style.top = "auto"; }

      const vv = window.visualViewport;
      const kbLikely = vv ? (vv.height < window.innerHeight * 0.7) : (window.innerHeight < 500);
      if (kbLikely && rectsOverlap(hudEl.getBoundingClientRect(), taRect, 0)) {
        hudEl.style.opacity = "0";
        hudEl.style.pointerEvents = "none";
      } else {
        hudEl.style.opacity = "1";
        hudEl.style.pointerEvents = "auto";
      }
    }

    // ---------- Guided Tour ----------
    const TOUR_STEPS = [
      { sel: "#chapters", text: "Stelle hier die Anzahl deiner Kapitel ein." },
      { sel: "#chapterControls", text: "Wechsle das Kapitel mit den Pfeilen oder gib die Nummer direkt ein." },
      { sel: "#minTotal", text: "Setze das gewünschte Gesamt-Minimum an Zeichen für dein Buch." },
      { sel: "#maxTotal", text: "Und hier das Gesamt-Maximum, das du nicht überschreiten möchtest." },
      { sel: "#hud", text: "Im HUD siehst du live Ist/Soll, Fortschrittsbalken und Delta – dein Kompass beim Schreiben." },
      { sel: "#lsExport", text: "Sichere deinen Stand als LocalStorage-Backup (JSON), um ihn später wieder zu laden." },
      { sel: "#lsImportBtn", text: "Hier kannst du ein Backup laden. Achtung: Überschreibt deinen aktuellen Stand!" },
    ];
    let tourIndex = 0;

    function ensureHUDVisibleForTour() {
      if (!state.hudVisible) {
        state.hudVisible = true;
        hudEl.style.display = "block";
        toggleHudBtn.setAttribute("aria-expanded", "true");
        toggleHudBtn.textContent = "HUD ausblenden";
        autoPlaceHUD();
      }
    }

    function positionSpotAndBox(target) {
      const pad = 8;
      const r = target.getBoundingClientRect();
      const spotLeft = Math.max(8, r.left - pad);
      const spotTop = Math.max(8, r.top - pad + window.scrollY);
      const spotWidth = r.width + pad * 2;
      const spotHeight = r.height + pad * 2;

      tourSpot.style.left = `${spotLeft}px`;
      tourSpot.style.top = `${spotTop}px`;
      tourSpot.style.width = `${spotWidth}px`;
      tourSpot.style.height = `${spotHeight}px`;

      // Place box below if space, else above, else to the right
      const viewportH = window.innerHeight;
      const belowY = r.bottom + 12 + window.scrollY;
      const aboveY = r.top - 12 - tourBox.offsetHeight + window.scrollY;
      const rightX = Math.min(window.scrollX + window.innerWidth - tourBox.offsetWidth - 12, r.right + 12 + window.scrollX);
      let boxTop, boxLeft;

      if (r.bottom + 12 + tourBox.offsetHeight < viewportH) {
        boxTop = belowY;
        boxLeft = Math.min(Math.max(12 + window.scrollX, r.left + window.scrollX), window.scrollX + window.innerWidth - tourBox.offsetWidth - 12);
      } else if (r.top - 12 - tourBox.offsetHeight > 0) {
        boxTop = aboveY;
        boxLeft = Math.min(Math.max(12 + window.scrollX, r.left + window.scrollX), window.scrollX + window.innerWidth - tourBox.offsetWidth - 12);
      } else {
        boxTop = Math.max(12 + window.scrollY, r.top + window.scrollY);
        boxLeft = rightX;
      }
      tourBox.style.top = `${boxTop}px`;
      tourBox.style.left = `${boxLeft}px`;
    }

    function goTour(i) {
      tourIndex = clamp(i, 0, TOUR_STEPS.length - 1);
      const step = TOUR_STEPS[tourIndex];
      const target = document.querySelector(step.sel);
      if (!target) { // skip missing
        if (tourIndex < TOUR_STEPS.length - 1) return goTour(tourIndex + 1);
        endTour(true);
        return;
      }
      target.scrollIntoView({ block: "center", behavior: "smooth" });
      setTimeout(() => { // allow scroll
        tourText.textContent = step.text;
        tourProgress.textContent = `Schritt ${tourIndex + 1} / ${TOUR_STEPS.length}`;
        positionSpotAndBox(target);
        tourPrev.disabled = tourIndex === 0;
        tourNext.textContent = tourIndex === TOUR_STEPS.length - 1 ? "Fertig" : "Weiter";
      }, 200);
    }

    function startTour(auto = false) {
      ensureHUDVisibleForTour();
      tourEl.classList.add("active");
      tourEl.style.display = "block";
      goTour(0);
      if (auto) localStorage.setItem(TOUR_FLAG, "in_progress");
    }
    function endTour(markDone = false) {
      tourEl.classList.remove("active");
      tourEl.style.display = "none";
      if (markDone) localStorage.setItem(TOUR_FLAG, "1");
    }

    // ---------- Events ----------
    // Text input
    textEl.addEventListener("input", () => { updateUI(); });
    textEl.addEventListener("scroll", () => {
      const nearBottom = textEl.scrollTop + textEl.clientHeight >= textEl.scrollHeight - 50;
      hudEl.style.opacity = nearBottom ? "0" : "1";
      hudEl.style.pointerEvents = nearBottom ? "none" : "auto";
    });

    // Chapters & arrows
    chaptersEl.addEventListener("input", () => { updateUI(); saveNow(); });
    currentEl.addEventListener("input", () => { updateUI(); saveNow(); });
    prevChapterBtn.addEventListener("click", () => stepChapter(-1));
    nextChapterBtn.addEventListener("click", () => stepChapter(+1));

    // Min/Max
    minTotalEl.addEventListener("input", () => {
      const v = parseInt(minTotalEl.value, 10);
      if (Number.isFinite(v)) state.minTotal = Math.max(0, v);
      updateUI(); saveNow();
    });
    maxTotalEl.addEventListener("input", () => {
      const v = parseInt(maxTotalEl.value, 10);
      if (Number.isFinite(v)) state.maxTotal = Math.max(0, v);
      updateUI(); saveNow();
    });
    minTotalEl.addEventListener("blur", () => { const v = parseInt(minTotalEl.value, 10); if (!Number.isFinite(v)) minTotalEl.value = state.minTotal; });
    maxTotalEl.addEventListener("blur", () => { const v = parseInt(maxTotalEl.value, 10); if (!Number.isFinite(v)) maxTotalEl.value = state.maxTotal; });

    // Autosave
    autosaveToggleEl.addEventListener("change", () => { scheduleAutosave(); saveNow(); });
    intervalEl.addEventListener("input", () => { scheduleAutosave(); saveNow(); });

    // Save/Export/Import
    saveBtn.addEventListener("click", () => saveNow());
    exportBtn.addEventListener("click", exportTxt);
    importBtn.addEventListener("click", () => importFileEl.click());
    importFileEl.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      textEl.value = text;
      updateUI();
      saveNow("Import");
      importFileEl.value = "";
    });
    clearBtn.addEventListener("click", clearAll);

    // HUD controls & safe toggle (never lose it)
    function setHudVisible(v) {
      state.hudVisible = !!v;
      hudEl.style.display = state.hudVisible ? "block" : "none";
      toggleHudBtn.textContent = state.hudVisible ? "HUD ausblenden" : "HUD einblenden";
      toggleHudBtn.setAttribute("aria-expanded", state.hudVisible ? "true" : "false");
      if (state.hudVisible) autoPlaceHUD();
    }
    toggleHudBtn.addEventListener("click", () => setHudVisible(!state.hudVisible));
    hudHideBtn.addEventListener("click", () => setHudVisible(false));
    // Keyboard shortcut: H toggles HUD
    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "h" && !e.metaKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault(); setHudVisible(!state.hudVisible);
      }
    });

    // Compact mode
    function setCompact(v) {
      state.compact = !!v;
      hudEl.classList.toggle("compact", state.compact);
      hudCompactBtn.classList.toggle("toggled", state.compact);
      toggleCompactBtn.classList.toggle("toggled", state.compact);
      updateUI(); saveNow();
    }
    hudCompactBtn.addEventListener("click", () => setCompact(!state.compact));
    toggleCompactBtn.addEventListener("click", () => setCompact(!state.compact));

    // Guided Tour bindings
    function handleResizeReposition() {
      if (!tourEl.classList.contains("active")) return;
      const step = TOUR_STEPS[tourIndex];
      const target = document.querySelector(step.sel);
      if (target) positionSpotAndBox(target);
    }
    window.addEventListener("resize", () => { autoPlaceHUD(); handleResizeReposition(); });
    window.addEventListener("scroll", handleResizeReposition);

    tourPrev.addEventListener("click", () => goTour(tourIndex - 1));
    tourNext.addEventListener("click", () => {
      if (tourIndex >= TOUR_STEPS.length - 1) endTour(true);
      else goTour(tourIndex + 1);
    });
    tourSkip.addEventListener("click", () => endTour(true));
    el("startTour").addEventListener("click", () => startTour(false));
    hudHelpBtn.addEventListener("click", () => startTour(false));

    // LocalStorage Export/Import
    lsExportBtn.addEventListener("click", () => {
      const data = localStorage.getItem(LS_KEY) || "{}";
      const blob = new Blob([data], { type: "application/json;charset=utf-8" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "zeichenzaehler_localstorage_backup.json";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    });
    lsImportBtn.addEventListener("click", () => {
      if (!confirm("Achtung: Der aktuelle LocalStorage-Eintrag wird überschrieben. Fortfahren?")) return;
      lsImportFile.click();
    });
    lsImportFile.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        let parsed;
        try { parsed = JSON.parse(text); } catch { parsed = null; }
        if (parsed && typeof parsed === "object" && (parsed.chapters || parsed.text !== undefined)) {
          localStorage.setItem(LS_KEY, JSON.stringify(parsed));
        } else {
          localStorage.setItem(LS_KEY, text);
        }
        loadFromStorage();
        alert("Import erfolgreich. Der vorherige LocalStorage-Eintrag wurde überschrieben.");
      } catch {
        alert("Fehler beim Import.");
      } finally {
        lsImportFile.value = "";
      }
    });

    // VisualViewport
    if (window.visualViewport) {
      visualViewport.addEventListener("resize", autoPlaceHUD);
      visualViewport.addEventListener("scroll", autoPlaceHUD);
    }

    // ---------- Init ----------
    loadFromStorage();
    setHudVisible(true);
    autoPlaceHUD();
    // Auto-start tour on first run
    if (!localStorage.getItem(TOUR_FLAG)) {
      startTour(true);
    }
    // Before unload autosave
    window.addEventListener("beforeunload", () => saveNow("Auto (beim Schließen)"));
  </script>
</body>
</html>
